"""Quiz models for interactive chapter quizzes.

Maps to the 'quizzes' and 'quiz_questions' tables in the database.
"""

from datetime import datetime
from typing import List, TYPE_CHECKING
from uuid import UUID, uuid4

from sqlalchemy import (
    CheckConstraint,
    ForeignKey,
    Integer,
    String,
    Text,
    TIMESTAMP,
    Enum as SQLEnum
)
from sqlalchemy.dialects.postgresql import UUID as PGUUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func
import enum

from .base import Base

if TYPE_CHECKING:
    from .chapter import Chapter


class ValidationStatus(str, enum.Enum):
    """Validation status for AI-generated content."""
    VALID = "valid"
    INVALID = "invalid"
    PENDING_REVIEW = "pending_review"


class QuestionDifficulty(str, enum.Enum):
    """Difficulty level for quiz questions."""
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"


class Quiz(Base):
    """Collection of quiz questions for a chapter.

    Each chapter has one quiz with 5-7 multiple choice questions to test
    learner comprehension of the material.

    Constitution Compliance:
    - 5-7 questions per quiz (User Story 3 requirement)
    - Generated by Claude 3 Haiku for cost efficiency (Principle III)
    - Immediate feedback for interactive learning (Principle I: AI-Native Design)

    Attributes:
        id: Unique identifier (UUID)
        chapter_id: Foreign key to chapters (1-to-1)
        total_questions: Number of questions in quiz (must be 5-7)
        model_used: LLM model identifier used for generation
        validation_status: Content validation status
        generated_at: Timestamp when quiz was generated
        chapter: Related Chapter
        questions: Related QuizQuestion objects (1-to-many)
    """

    __tablename__ = "quizzes"

    # Primary key
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        server_default=func.gen_random_uuid()
    )

    # Foreign keys (1-to-1 with chapters)
    chapter_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("chapters.id", ondelete="CASCADE"),
        nullable=False,
        unique=True
    )

    # Quiz metadata
    total_questions: Mapped[int] = mapped_column(
        Integer,
        nullable=False
    )

    # Generation metadata
    model_used: Mapped[str] = mapped_column(
        String(100),
        nullable=False
    )
    validation_status: Mapped[ValidationStatus] = mapped_column(
        SQLEnum(ValidationStatus, name="validation_status", create_constraint=True),
        nullable=False,
        server_default="pending_review"
    )

    # Timestamp
    generated_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now()
    )

    # Relationships
    chapter: Mapped["Chapter"] = relationship(
        "Chapter",
        back_populates="quiz"
    )
    questions: Mapped[List["QuizQuestion"]] = relationship(
        "QuizQuestion",
        back_populates="quiz",
        cascade="all, delete-orphan",
        order_by="QuizQuestion.question_number"
    )

    # Constraints (Constitution compliance)
    __table_args__ = (
        CheckConstraint(
            "total_questions >= 5 AND total_questions <= 7",
            name="check_total_questions"
        ),
    )

    def __repr__(self) -> str:
        return (
            f"<Quiz(chapter_id={self.chapter_id}, "
            f"questions={self.total_questions}, status={self.validation_status.value})>"
        )

    @property
    def is_valid(self) -> bool:
        """Check if quiz has valid number of questions (5-7)."""
        return 5 <= self.total_questions <= 7

    @property
    def question_count(self) -> int:
        """Get actual number of questions (from relationship)."""
        return len(self.questions) if self.questions else 0

    def validate_questions(self) -> list[str]:
        """Validate quiz questions and return any errors.

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        if not self.questions:
            errors.append("No questions provided")
            return errors

        actual_count = len(self.questions)
        if actual_count != self.total_questions:
            errors.append(
                f"Question count mismatch: total_questions={self.total_questions}, "
                f"actual={actual_count}"
            )

        if actual_count < 5:
            errors.append(f"Too few questions: {actual_count} (minimum 5)")
        elif actual_count > 7:
            errors.append(f"Too many questions: {actual_count} (maximum 7)")

        return errors


class QuizQuestion(Base):
    """Individual multiple choice question in a quiz.

    Each question has 4 options with exactly one correct answer.

    Constitution Compliance:
    - 4 options per question (standard multiple choice)
    - Exactly 1 correct answer (correct_index 0-3)
    - Difficulty levels for balanced assessment
    - Topic tagging for content tracking

    Attributes:
        id: Unique identifier (UUID)
        quiz_id: Foreign key to quizzes
        question_number: Sequential number within quiz (1-7)
        question_text: The question text
        options: List of 4 answer options (JSONB array of strings)
        correct_index: Index of correct option (0-3)
        difficulty: Question difficulty level (easy/medium/hard)
        topic: Main topic/concept tested by this question
        created_at: Creation timestamp
        quiz: Related Quiz
    """

    __tablename__ = "quiz_questions"

    # Primary key
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        server_default=func.gen_random_uuid()
    )

    # Foreign keys
    quiz_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("quizzes.id", ondelete="CASCADE"),
        nullable=False
    )

    # Question metadata
    question_number: Mapped[int] = mapped_column(
        Integer,
        nullable=False
    )
    question_text: Mapped[str] = mapped_column(
        Text,
        nullable=False
    )

    # Answer data
    options: Mapped[list] = mapped_column(
        JSONB,
        nullable=False
    )
    correct_index: Mapped[int] = mapped_column(
        Integer,
        nullable=False
    )

    # Classification
    difficulty: Mapped[QuestionDifficulty] = mapped_column(
        SQLEnum(QuestionDifficulty, name="question_difficulty", create_constraint=True),
        nullable=False
    )
    topic: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )

    # Timestamp
    created_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now()
    )

    # Relationships
    quiz: Mapped["Quiz"] = relationship(
        "Quiz",
        back_populates="questions"
    )

    # Constraints
    __table_args__ = (
        CheckConstraint(
            "correct_index >= 0 AND correct_index <= 3",
            name="check_correct_index"
        ),
    )

    def __repr__(self) -> str:
        return (
            f"<QuizQuestion(number={self.question_number}, "
            f"difficulty={self.difficulty.value}, topic='{self.topic}')>"
        )

    @property
    def correct_answer(self) -> str:
        """Get the correct answer text."""
        if not self.options or self.correct_index >= len(self.options):
            return ""
        return self.options[self.correct_index]

    def is_correct(self, selected_index: int) -> bool:
        """Check if selected answer index is correct.

        Args:
            selected_index: Index of selected option (0-3)

        Returns:
            True if selected_index matches correct_index
        """
        return selected_index == self.correct_index

    def validate_options(self) -> list[str]:
        """Validate question options and return any errors.

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        if not self.options:
            errors.append("No options provided")
            return errors

        if len(self.options) != 4:
            errors.append(
                f"Invalid option count: {len(self.options)} (must be exactly 4)"
            )

        if self.correct_index < 0 or self.correct_index > 3:
            errors.append(
                f"Invalid correct_index: {self.correct_index} (must be 0-3)"
            )

        for i, option in enumerate(self.options):
            if not isinstance(option, str):
                errors.append(f"Option {i} is not a string")
            elif not option.strip():
                errors.append(f"Option {i} is empty")

        return errors
