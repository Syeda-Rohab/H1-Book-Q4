"""Learning Booster model for supplementary learning content.

Maps to the 'learning_boosters' table in the database.
"""

from datetime import datetime
from typing import TYPE_CHECKING
from uuid import UUID, uuid4

from sqlalchemy import (
    CheckConstraint,
    ForeignKey,
    Integer,
    String,
    Text,
    TIMESTAMP,
    Enum as SQLEnum
)
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func
import enum

from .base import Base

if TYPE_CHECKING:
    from .chapter import Chapter


class BoosterType(str, enum.Enum):
    """Type of learning booster content."""
    ANALOGY = "analogy"
    EXAMPLE = "example"
    EXPLANATION = "explanation"


class ValidationStatus(str, enum.Enum):
    """Validation status for AI-generated content."""
    VALID = "valid"
    INVALID = "invalid"
    PENDING_REVIEW = "pending_review"


class LearningBooster(Base):
    """Supplementary learning content to enhance understanding.

    Each chapter has 2-3 learning boosters strategically placed to provide
    additional context through analogies, examples, or explanations.

    Constitution Compliance:
    - 2-3 boosters per chapter (User Story 4 requirement)
    - Generated by Claude 3 Haiku for cost efficiency (Principle III)
    - 100-300 characters for clarity and brevity (Principle II: Speed & Simplicity)
    - Positioned strategically in content (position 1-3)

    Booster Types:
    - analogy: Relates concept to familiar real-world comparison
    - example: Provides concrete example of the concept
    - explanation: Clarifies complex or confusing points

    Attributes:
        id: Unique identifier (UUID)
        chapter_id: Foreign key to chapters
        booster_type: Type of booster (analogy/example/explanation)
        content: The booster text content (100-300 chars)
        section_ref: Reference to chapter section where booster appears
        position: Display position within chapter (1-3)
        model_used: LLM model identifier used for generation
        validation_status: Content validation status
        generated_at: Timestamp when booster was generated
        chapter: Related Chapter
    """

    __tablename__ = "learning_boosters"

    # Primary key
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        server_default=func.gen_random_uuid()
    )

    # Foreign keys
    chapter_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("chapters.id", ondelete="CASCADE"),
        nullable=False
    )

    # Content
    booster_type: Mapped[BoosterType] = mapped_column(
        SQLEnum(BoosterType, name="booster_type", create_constraint=True),
        nullable=False
    )
    content: Mapped[str] = mapped_column(
        Text,
        nullable=False
    )

    # Positioning
    section_ref: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )
    position: Mapped[int] = mapped_column(
        Integer,
        nullable=False
    )

    # Generation metadata
    model_used: Mapped[str] = mapped_column(
        String(100),
        nullable=False
    )
    validation_status: Mapped[ValidationStatus] = mapped_column(
        SQLEnum(ValidationStatus, name="validation_status", create_constraint=True),
        nullable=False,
        server_default="pending_review"
    )

    # Timestamp
    generated_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now()
    )

    # Relationships
    chapter: Mapped["Chapter"] = relationship(
        "Chapter",
        back_populates="learning_boosters"
    )

    # Constraints
    __table_args__ = (
        CheckConstraint(
            "position >= 1 AND position <= 3",
            name="check_position"
        ),
    )

    def __repr__(self) -> str:
        return (
            f"<LearningBooster(type={self.booster_type.value}, "
            f"position={self.position}, section='{self.section_ref}')>"
        )

    @property
    def content_length(self) -> int:
        """Get length of content in characters."""
        return len(self.content) if self.content else 0

    @property
    def is_valid_length(self) -> bool:
        """Check if content length is within valid range (100-300 chars)."""
        length = self.content_length
        return 100 <= length <= 300

    def validate_content(self) -> list[str]:
        """Validate booster content and return any errors.

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        if not self.content:
            errors.append("Content is empty")
            return errors

        length = len(self.content)
        if length < 100:
            errors.append(f"Content too short: {length} chars (minimum 100)")
        elif length > 300:
            errors.append(f"Content too long: {length} chars (maximum 300)")

        if self.position < 1 or self.position > 3:
            errors.append(f"Invalid position: {self.position} (must be 1-3)")

        if not self.section_ref:
            errors.append("Section reference is empty")

        return errors

    @classmethod
    def get_icon(cls, booster_type: BoosterType) -> str:
        """Get emoji icon for booster type.

        Args:
            booster_type: Type of booster

        Returns:
            Emoji icon string
        """
        icons = {
            BoosterType.ANALOGY: "üîÑ",
            BoosterType.EXAMPLE: "üí°",
            BoosterType.EXPLANATION: "üìñ"
        }
        return icons.get(booster_type, "‚ÑπÔ∏è")
