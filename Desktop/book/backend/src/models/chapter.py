"""Chapter models for textbook content.

Maps to the 'chapters' and 'chapter_contents' tables in the database.
"""

from datetime import datetime
from typing import Optional, TYPE_CHECKING
from uuid import UUID, uuid4

from sqlalchemy import (
    CheckConstraint,
    ForeignKey,
    Integer,
    String,
    Text,
    TIMESTAMP,
    Enum as SQLEnum
)
from sqlalchemy.dialects.postgresql import UUID as PGUUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func
import enum

from .base import Base

if TYPE_CHECKING:
    from .generation_job import GenerationJob
    from .summary import Summary
    from .quiz import Quiz
    from .learning_booster import LearningBooster


class ChapterStatus(str, enum.Enum):
    """Status of a chapter in the generation pipeline."""
    PENDING = "pending"
    GENERATED = "generated"
    VALIDATED = "validated"
    PUBLISHED = "published"
    FAILED = "failed"


class Chapter(Base):
    """Represents a textbook chapter with metadata.

    Each chapter is part of the AI-Native Physical AI & Humanoid Robotics textbook.
    Chapters are generated by LLMs and must comply with constitution constraints.

    Constitution Compliance:
    - Word count: 800-1200 words (Principle VII: Content Quality Over Quantity)
    - Reading time: 5-7 minutes (enforced by constraint)
    - Chapter numbers: 1-8 (6-8 chapters total per constitution)
    - Mobile-responsive content (Principle VI: Mobile-First Design)

    Attributes:
        id: Unique identifier (UUID)
        job_id: Foreign key to generation_jobs
        chapter_number: Sequential chapter number (1-8, unique)
        title: Chapter title
        slug: URL-friendly slug for Docusaurus
        word_count: Total word count (must be 800-1200)
        reading_time_minutes: Estimated reading time (must be 5-7)
        status: Current chapter status
        validation_errors: List of validation error messages (JSONB)
        created_at: Creation timestamp
        updated_at: Last update timestamp
        job: Related GenerationJob
        content: Related ChapterContent (1-to-1)
        summary: Related Summary (1-to-1)
        quiz: Related Quiz (1-to-1)
        learning_boosters: Related LearningBooster objects (1-to-many)
    """

    __tablename__ = "chapters"

    # Primary key
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        server_default=func.gen_random_uuid()
    )

    # Foreign keys
    job_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("generation_jobs.id", ondelete="CASCADE"),
        nullable=False
    )

    # Chapter identification
    chapter_number: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        unique=True
    )
    title: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )
    slug: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        unique=True
    )

    # Content metrics (Constitution constraints)
    word_count: Mapped[int] = mapped_column(
        Integer,
        nullable=False
    )
    reading_time_minutes: Mapped[int] = mapped_column(
        Integer,
        nullable=False
    )

    # Status tracking
    status: Mapped[ChapterStatus] = mapped_column(
        SQLEnum(ChapterStatus, name="chapter_status", create_constraint=True),
        nullable=False,
        server_default="pending"
    )
    validation_errors: Mapped[list] = mapped_column(
        JSONB,
        nullable=False,
        server_default="[]"
    )

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now(),
        onupdate=func.now()
    )

    # Relationships
    job: Mapped["GenerationJob"] = relationship(
        "GenerationJob",
        back_populates="chapters"
    )
    content: Mapped[Optional["ChapterContent"]] = relationship(
        "ChapterContent",
        back_populates="chapter",
        cascade="all, delete-orphan",
        uselist=False
    )
    summary: Mapped[Optional["Summary"]] = relationship(
        "Summary",
        back_populates="chapter",
        cascade="all, delete-orphan",
        uselist=False
    )
    quiz: Mapped[Optional["Quiz"]] = relationship(
        "Quiz",
        back_populates="chapter",
        cascade="all, delete-orphan",
        uselist=False
    )
    learning_boosters: Mapped[list["LearningBooster"]] = relationship(
        "LearningBooster",
        back_populates="chapter",
        cascade="all, delete-orphan"
    )

    # Constraints (Constitution compliance)
    __table_args__ = (
        CheckConstraint(
            "chapter_number >= 1 AND chapter_number <= 8",
            name="check_chapter_number"
        ),
        CheckConstraint(
            "word_count >= 800 AND word_count <= 1200",
            name="check_word_count"
        ),
        CheckConstraint(
            "reading_time_minutes >= 5 AND reading_time_minutes <= 7",
            name="check_reading_time"
        ),
    )

    def __repr__(self) -> str:
        return (
            f"<Chapter(number={self.chapter_number}, title='{self.title}', "
            f"status={self.status.value}, words={self.word_count})>"
        )

    @property
    def is_published(self) -> bool:
        """Check if chapter is published and ready for users."""
        return self.status == ChapterStatus.PUBLISHED

    @property
    def meets_constitution(self) -> bool:
        """Check if chapter meets constitution requirements."""
        return (
            800 <= self.word_count <= 1200 and
            5 <= self.reading_time_minutes <= 7 and
            1 <= self.chapter_number <= 8
        )

    def add_validation_error(self, error_message: str) -> None:
        """Add a validation error message.

        Args:
            error_message: Error description to record
        """
        if self.validation_errors is None:
            self.validation_errors = []
        self.validation_errors.append({
            "message": error_message,
            "timestamp": datetime.utcnow().isoformat()
        })


class ChapterContent(Base):
    """Stores chapter content file references and metadata.

    Each chapter has one ChapterContent record that tracks the markdown file
    location, content hash for change detection, and Docusaurus URL.

    Attributes:
        id: Unique identifier (UUID)
        chapter_id: Foreign key to chapters (1-to-1)
        markdown_path: File path to markdown file (e.g., website/docs/chapter-1.md)
        content_hash: SHA-256 hash of markdown content for change detection
        docusaurus_url: Public URL path in Docusaurus (e.g., /docs/chapter-1)
        stored_at: Timestamp when file was written
        chapter: Related Chapter
    """

    __tablename__ = "chapter_contents"

    # Primary key
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        server_default=func.gen_random_uuid()
    )

    # Foreign keys (1-to-1 with chapters)
    chapter_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("chapters.id", ondelete="CASCADE"),
        nullable=False,
        unique=True
    )

    # File metadata
    markdown_path: Mapped[str] = mapped_column(
        String(500),
        nullable=False
    )
    content_hash: Mapped[str] = mapped_column(
        String(64),
        nullable=False
    )
    docusaurus_url: Mapped[str] = mapped_column(
        String(500),
        nullable=False
    )

    # Timestamp
    stored_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now()
    )

    # Relationships
    chapter: Mapped["Chapter"] = relationship(
        "Chapter",
        back_populates="content"
    )

    def __repr__(self) -> str:
        return (
            f"<ChapterContent(chapter_id={self.chapter_id}, "
            f"path='{self.markdown_path}')>"
        )
