"""Summary model for chapter summaries.

Maps to the 'summaries' table in the database.
"""

from datetime import datetime
from typing import TYPE_CHECKING
from uuid import UUID, uuid4

from sqlalchemy import ForeignKey, String, TIMESTAMP, Enum as SQLEnum
from sqlalchemy.dialects.postgresql import UUID as PGUUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.sql import func
import enum

from .base import Base

if TYPE_CHECKING:
    from .chapter import Chapter


class ValidationStatus(str, enum.Enum):
    """Validation status for AI-generated content."""
    VALID = "valid"
    INVALID = "invalid"
    PENDING_REVIEW = "pending_review"


class Summary(Base):
    """AI-generated chapter summary with key takeaways.

    Each chapter has one summary that provides 3-5 concise takeaways to help
    learners retain the most important concepts.

    Constitution Compliance:
    - 3-5 takeaways per summary (User Story 2 requirement)
    - Generated by Claude 3 Haiku for cost efficiency (Principle III)
    - Each takeaway: 50-150 characters for clarity (Principle II: Speed & Simplicity)

    Attributes:
        id: Unique identifier (UUID)
        chapter_id: Foreign key to chapters (1-to-1)
        takeaways: List of 3-5 key takeaways (JSONB array of strings)
        model_used: LLM model identifier used for generation
        validation_status: Content validation status
        generated_at: Timestamp when summary was generated
        chapter: Related Chapter
    """

    __tablename__ = "summaries"

    # Primary key
    id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        primary_key=True,
        default=uuid4,
        server_default=func.gen_random_uuid()
    )

    # Foreign keys (1-to-1 with chapters)
    chapter_id: Mapped[UUID] = mapped_column(
        PGUUID(as_uuid=True),
        ForeignKey("chapters.id", ondelete="CASCADE"),
        nullable=False,
        unique=True
    )

    # Content
    takeaways: Mapped[list] = mapped_column(
        JSONB,
        nullable=False
    )

    # Generation metadata
    model_used: Mapped[str] = mapped_column(
        String(100),
        nullable=False
    )
    validation_status: Mapped[ValidationStatus] = mapped_column(
        SQLEnum(ValidationStatus, name="validation_status", create_constraint=True),
        nullable=False,
        server_default="pending_review"
    )

    # Timestamp
    generated_at: Mapped[datetime] = mapped_column(
        TIMESTAMP(timezone=True),
        nullable=False,
        server_default=func.now()
    )

    # Relationships
    chapter: Mapped["Chapter"] = relationship(
        "Chapter",
        back_populates="summary"
    )

    def __repr__(self) -> str:
        takeaway_count = len(self.takeaways) if self.takeaways else 0
        return (
            f"<Summary(chapter_id={self.chapter_id}, "
            f"takeaways={takeaway_count}, status={self.validation_status.value})>"
        )

    @property
    def is_valid(self) -> bool:
        """Check if summary has valid number of takeaways (3-5)."""
        if not self.takeaways:
            return False
        return 3 <= len(self.takeaways) <= 5

    @property
    def takeaway_count(self) -> int:
        """Get the number of takeaways."""
        return len(self.takeaways) if self.takeaways else 0

    def validate_takeaways(self) -> list[str]:
        """Validate takeaway content and return any errors.

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        if not self.takeaways:
            errors.append("No takeaways provided")
            return errors

        if len(self.takeaways) < 3:
            errors.append(f"Too few takeaways: {len(self.takeaways)} (minimum 3)")
        elif len(self.takeaways) > 5:
            errors.append(f"Too many takeaways: {len(self.takeaways)} (maximum 5)")

        for i, takeaway in enumerate(self.takeaways, start=1):
            if not isinstance(takeaway, str):
                errors.append(f"Takeaway {i} is not a string")
                continue

            length = len(takeaway)
            if length < 50:
                errors.append(
                    f"Takeaway {i} too short: {length} chars (minimum 50)"
                )
            elif length > 150:
                errors.append(
                    f"Takeaway {i} too long: {length} chars (maximum 150)"
                )

        return errors
